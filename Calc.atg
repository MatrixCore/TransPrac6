using Library;
using System.Collections.Generic;

COMPILER Calc $NC
//  GROUP B: William Carpenter-Frank, Ryan McDonald, Matthew Pitcairn

public struct MyVar
{
	public string Name;
	public int Type; //NoType = 0, IntType = 1, BoolType = 2
	public int Value;

	public MyVar(string name, int type, int val)
		{
			Name = name;
			Type = type;
			Value = val;
		}
}
public List<MyVar> SymTable = new List<MyVar>();

public bool VarExists(string name) {
	foreach (MyVar temp in SymTable)
	{
		if (name == temp.Name) return true;
	}
	return false;
}

public void VarAdd (MyVar ToAdd) {
	if (!(VarExists(ToAdd.Name))) { SymTable.Add(ToAdd); }
	else
	{
		foreach (MyVar temp in SymTable)
		{
			if (temp.Name == ToAdd.Name)
			{
				SymTable.Remove(temp);
				SymTable.Add(ToAdd);
			}
		}
	}
}

public int VarGet(string name) {
	if (VarExists(name))
	{
		foreach (MyVar temp in SymTable)
		{
			if (name == temp.Name) return temp.Value;
		}
	}
	return -1;
}

public bool VarCompatible (MyVar Uno, MyVar Dos)     
{
	if (Uno.Type != Dos.Type)
	{
		return false;
	}
	return true;
}

static int ToInt(bool b) {
// return 0 or 1 according as b is false or true
  return b ? 1 : 0;
} // ToInt

static bool ToBool(int i) {
// return false or true according as i is 0 or 1
  return i == 0 ? false : true;
} // ToBool

CHARACTERS
  digit      = "0123456789" .
  letter     = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .

TOKENS
  number     = digit { digit } .
  identifier = letter { letter | digit } .

IGNORE CHR(0) .. CHR(31)

PRODUCTIONS
  Calc
  =
  { Print 
  | (. MyVar final; .)
    Assignment<out final> (. VarAdd(final); .)
  } "quit"
  .

  Assignment <out MyVar goal> (. goal = new MyVar("", 0 , 0); string name = ""; int value = 0; .)
  =
  Variable <out name> (. goal.Name = name; .)
  "="
  Expression<out value> (. goal.Value = value; .)
  SYNC ";" 				
  .

  Print 
  =
  "print" (. int value = 0; .) 
  Expression<out value> 
  { WEAK ","
    Expression<out value>
  }
  SYNC ";" (. IO.WriteLine(value); .)
  .

  Expression<out int EValue>    (. EValue = 0; MyVar andValue, otherVal; .)
  =								 
  AndExp<out andValue>			(. EValue = andValue.Value; .)		
  { "||"						
    AndExp<out otherVal> 		(. EValue = ToInt(ToBool(andValue.Value) || ToBool(otherVal.Value)); .)
  } . 							

  AndExp<out MyVar andValue> 		(. andValue = new MyVar("", 0 , 0); MyVar otherEqualVal, equalValue; .)
  =
  EqlExp<out equalValue>	  	(. andValue.Value = equalValue.Value; .)
  { "&&"					   
    EqlExp<out otherEqualVal>  (. andValue.Value = ToInt(ToBool(equalValue.Value) && ToBool(otherEqualVal.Value)); .)
  } .

  EqlExp<out MyVar equalValue> (. equalValue = new MyVar("", 0 , 0); MyVar relValue, otherRelVal; string EqlSym;.)
  =
  RelExp<out relValue>		  (. equalValue.Value = relValue.Value; .)
  { EqlOp <out EqlSym>
    RelExp<out otherRelVal>  (. if (EqlSym == "==") { equalValue.Value = ToInt(ToBool(relValue.Value) == ToBool(otherRelVal.Value)); }
									else { equalValue.Value = ToInt(ToBool(relValue.Value) != ToBool(otherRelVal.Value)); } .) 
  } .

  RelExp<out MyVar relValue> (. relValue = new MyVar("", 0 , 0); MyVar addValue, OtherAddVal; string relSym; .)
  =
  AddExp<out addValue>		(. relValue.Value = addValue.Value; .)
  [ RelOp<out relSym>
    AddExp<out OtherAddVal>	(.	switch (relSym)
							{
								case "<":
									relValue.Value = ToInt(addValue.Value < OtherAddVal.Value);
									break;
								case "<=":
									relValue.Value = ToInt(addValue.Value <= OtherAddVal.Value);
									break;
								case ">":
									relValue.Value = ToInt(addValue.Value > OtherAddVal.Value);
									break;
								case ">=":
									relValue.Value = ToInt(addValue.Value >= OtherAddVal.Value);
									break;
							}	.)
  ] .

  AddExp<out MyVar addValue> (. addValue = new MyVar("", 0 , 0); MyVar multValue, otherMulVal; string addOp; .)
  =
  MultExp<out multValue> (. addValue.Value = multValue.Value; .)
  { AddOp<out addOp>
    MultExp<out otherMulVal>			(. if (addOp == "+") { addValue.Value = multValue.Value + otherMulVal.Value; } 
											   else { addValue.Value = multValue.Value - otherMulVal.Value; }  .)
  } .

  MultExp<out MyVar multValue> (. multValue = new MyVar("", 0 , 0); MyVar unaryValue = 0, otherUnaryVal = 0; string mulOp; .)
  =
  UnaryExp<out unaryValue>	(. multValue.Value = unaryValue.Value; .)
  { MulOp<out mulOp>
    UnaryExp<out otherUnaryVal> 		(. switch (mulOp)
										{
											case "*":
											multValue.Value = unaryValue.Value * otherUnaryVal.Value;
											break;
											case "/":
											multValue.Value = unaryValue.Value / otherUnaryVal.Value;
											break;
											case "%":
											multValue.Value = unaryValue.Value / otherUnaryVal.Value;
											break;
										}

										.)
  } .

  UnaryExp <out MyVar unaryExp> (. unaryExp = new MyVar("", 0 , 0); MyVar OtherUnaryExp; MyVar FactorValue; FactorValue.Value = 0; .)
  =   Factor<out FactorValue> 		  (. unaryExp = FactorValue.Value; .)
    | "+" UnaryExp<out OtherUnaryExp> (. unaryExp.Value = OtherUnaryExp; unaryExp.Type = 1;.)
    | "-" UnaryExp<out OtherUnaryExp> (. unaryExp.Value = - OtherUnaryExp; unaryExp.Type = 1;.)
    | "!" UnaryExp<out OtherUnaryExp> (. unaryExp.Value = ToInt(!ToBool(OtherUnaryExp)); unaryExp.Type = 2; .)
  .

  Factor<out MyVar FactorValue> (. FactorValue = new MyVar("", 0 , 0); FactorValue.Value = 0; FactorValue.Name = ""; FactorValue.Type = -1; string name = ""; int NumValue = 0; int ExpVal = 0; .)
  =
      Variable <out name>   (. FactorValue.Name = name; FactorValue.Type = 0; .) 
    | Number<out NumValue>	(. FactorValue.Value = NumValue; FactorValue.Type = 1; .)
    | "true"				(. FactorValue.Value = 1; FactorValue.Type = 2; .)
    | "false"				(. FactorValue.Value = 0; FactorValue.Type = 2; .)
    | "(" Expression<out ExpVal>
      ")" 					(. FactorValue.Value = ExpVal; .)
  .

  Variable <out string name>
  =
  identifier (. name = token.val; .)
  .

  Number<out int numValue>
  =
  number  (. numValue = Convert.ToInt32(token.val); .)
  .

  MulOp<out string mulOp> (. mulOp = ""; .)
  =
      "*" (. mulOp = token.val; .)
    | "/" (. mulOp = token.val; .)
    | "%" (. mulOp = token.val; .)
    .

  AddOp<out string addOp> (. addOp = ""; .)
  =
      "+" (. addOp = token.val; .)
    | "-" (. addOp = token.val; .)
  .

  RelOp<out string relOp> (. relOp = ""; .)
  =
      "<"  (. relOp = token.val; .)
    | "<=" (. relOp = token.val; .)
    | ">"  (. relOp = token.val; .)
    | ">=" (. relOp = token.val; .)
  .

  EqlOp <out string eqlOp> (. eqlOp = ""; .)
  =
      "==" (. eqlOp = token.val; .)
    | "!=" (. eqlOp = token.val; .)
  .

END Calc.
