using Library;
using System.Collections.Generic;

COMPILER Calc $NC
//  GROUP B: William Carpenter-Frank, Ryan McDonald, Matthew Pitcairn

public struct MyVar
    {
	    public string Name;
	    public int Type; //NoType = 0, IntType = 1, BoolType = 2
	    public int Value;

        public MyVar(string name, int type, int val)
            {
                Name = name;
                Type = type;
                Value = val;
            }
    }
        public List<MyVar> SymTable = new List<MyVar>();

        public bool VarExists(string name) {
	        foreach (MyVar temp in SymTable)
	        {
		        if (name == temp.Name) return true;
	        }
	        return false;
        }

        public void VarAdd (MyVar ToAdd) {
	        if (!(VarExists(ToAdd.Name))) { SymTable.Add(ToAdd); }
	        else
            {
                foreach (MyVar temp in SymTable)
                {
                    if (temp.Name == ToAdd.Name)
                    {
                        SymTable.Remove(temp);
                        SymTable.Add(ToAdd);
                    }
                }
            }
        }

        public MyVar VarGet(string name) {
            if (VarExists(name))
            {
                foreach (MyVar temp in SymTable)
                {
                    if (name == temp.Name) return temp;
                }
            }
            return new MyVar("", 0, 0);
        }

        public bool VarCompatible (MyVar Uno, MyVar Dos)     
        {
            if (Uno.Type != Dos.Type)
            {
                return false;
            }
            return true;
        }

static int ToInt(bool b) {
// return 0 or 1 according as b is false or true
  return b ? 1 : 0;
} // ToInt

static bool ToBool(int i) {
// return false or true according as i is 0 or 1
  return i == 0 ? false : true;
} // ToBool

CHARACTERS
  digit      = "0123456789" .
  letter     = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .

TOKENS
  number     = digit { digit } .
  identifier = letter { letter | digit } .

IGNORE CHR(0) .. CHR(31)

PRODUCTIONS
  Calc
  =
  { Print 
  | (. int final = 0; .)
    Assignment<out final>
  } "quit"
  .

  Assignment <out int goal> (. goal = 0; string name = ""; int value = 0; .)
  =
  Variable <out name>
  "="
  Expression<out value>
  SYNC ";"
  .

  Print 
  =
  "print" (. int value = 0; .) 
  Expression<out value> 
  { WEAK ","
    Expression<out value>
  }
  SYNC ";" (. IO.WriteLine(value); .)
  .

  Expression<out int EValue>    (. EValue = 0; int andValue, otherVal; .)
  =								 
  AndExp<out andValue>			(. EValue = andValue; .)		
  { "||"						
    AndExp<out otherVal> 		(. bool value1 = ToBool(andValue); bool value2 = ToBool(otherVal); .) 
								// If you hit this production, convert the value coming up to a bool, otherwise it is a number
								(. EValue = ToInt(value1 || value2); .)
  } . 							

  AndExp<out int andValue> 		(. andValue = 0; int otherEqualVal, equalValue; .)
  =
  EqlExp<out equalValue>	  	(. andValue = equalValue; .)
  { "&&"					   
    EqlExp<out otherEqualVal>  (. bool value1 = ToBool(equalValue); bool value2 = ToBool(otherEqualVal); .) 
								// If you hit this production, convert the value coming up to a bool, otherwise it is a number
							   (. andValue = ToInt(value1 && value2); .)
  } .

  EqlExp<out int equalValue> (. equalValue = 0; int relValue, otherRelVal; string EqlSym;.)
  =
  RelExp<out relValue>		  (. equalValue = relValue; .)
  { EqlOp <out EqlSym>
    RelExp<out otherRelVal>  (. if (EqlSym == "==") { equalValue = ToInt(relValue == otherRelVal); }
									else { equalValue = ToInt(relValue != otherRelVal); } .) 
  } .

  RelExp<out int relValue> (. relValue = 0; int addValue, OtherAddVal; string relSym; .)
  =
  AddExp<out addValue>		(. relValue = addValue; .)
  [ RelOp<out relSym>
    AddExp<out OtherAddVal>	(.	switch (relSym)
							{
								case "<":
									relValue = ToInt(addValue < OtherAddVal);
									break;
								case "<=":
									relValue = ToInt(addValue <= OtherAddVal);
									break;
								case ">":
									relValue = ToInt(addValue > OtherAddVal);
									break;
								case ">=":
									relValue = ToInt(addValue >= OtherAddVal);
									break;
							}	.)
  ] .

  AddExp<out int addValue> (. addValue = 0; int multValue, otherMulVal; string addOp; .)
  =
  MultExp<out multValue> (. addValue = multValue; .)
  { AddOp<out addOp>
    MultExp<out otherMulVal>			(. if (addOp == "+") { addValue = multValue + otherMulVal; } 
											   else { addValue = multValue - otherMulVal; }  .)
  } .

  MultExp<out int multValue> (. multValue = 0; int UnaryValue = 0, otherUnaryVal = 0; string mulOp; .)
  =
  UnaryExp<out UnaryValue>	(. multValue = UnaryValue; .)
  { MulOp<out mulOp>
    UnaryExp<out otherUnaryVal> 		(. switch (mulOp)
										{
											case "*":
											multValue = UnaryValue * otherUnaryVal;
											break;
											case "/":
											multValue = UnaryValue / otherUnaryVal;
											break;
											case "%":
											multValue = UnaryValue / otherUnaryVal;
											break;
										}

										.)
  } .

  UnaryExp <out int unaryExp> (. unaryExp = 0; int OtherUnaryExp = 0; MyVar FactorValue; FactorValue.Value = 0; .)
  =   Factor<out FactorValue> 		  (. unaryExp = FactorValue.Value; .)
    | "+" UnaryExp<out OtherUnaryExp> (. unaryExp = FactorValue.Value + OtherUnaryExp; .)
    | "-" UnaryExp<out OtherUnaryExp> (. unaryExp = FactorValue.Value - OtherUnaryExp; .)
    | "!" UnaryExp<out OtherUnaryExp> (. unaryExp = ToInt(!ToBool(OtherUnaryExp)); .)
  .

  Factor<out MyVar FactorValue> (. FactorValue.Value = 0; FactorValue.Name = ""; FactorValue.Type = -1; string name = ""; int NumValue = 0; int ExpVal = 0; .)
  =
      Variable <out name>   (. FactorValue.Name = name; FactorValue.Type = 0; .) 
    | Number<out NumValue>	(. FactorValue.Value = NumValue; FactorValue.Type = 1; .)
    | "true"				(. FactorValue.Value = 1; FactorValue.Type = 2; .)
    | "false"				(. FactorValue.Value = 0; FactorValue.Type = 2; .)
    | "(" Expression<out ExpVal>
      ")" 					(. FactorValue.Value = ExpVal; .)
  .

  Variable <out string name>
  =
  identifier (. name = token.val; .)
  .

  Number<out int numValue>
  =
  number  (. numValue = Convert.ToInt32(token.val); .)
  .

  MulOp<out string mulOp> (. mulOp = ""; .)
  =
      "*" (. mulOp = token.val; .)
    | "/" (. mulOp = token.val; .)
    | "%" (. mulOp = token.val; .)
    .

  AddOp<out string addOp> (. addOp = ""; .)
  =
      "+" (. addOp = token.val; .)
    | "-" (. addOp = token.val; .)
  .

  RelOp<out string relOp> (. relOp = ""; .)
  =
      "<"  (. relOp = token.val; .)
    | "<=" (. relOp = token.val; .)
    | ">"  (. relOp = token.val; .)
    | ">=" (. relOp = token.val; .)
  .

  EqlOp <out string eqlOp> (. eqlOp = ""; .)
  =
      "==" (. eqlOp = token.val; .)
    | "!=" (. eqlOp = token.val; .)
  .

END Calc.
